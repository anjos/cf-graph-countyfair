{
 "PRed": [
  {
   "data": {
    "bot_rerun": false,
    "migrator_name": "Compiler",
    "migrator_version": 0
   },
   "keys": [
    "bot_rerun",
    "migrator_name",
    "migrator_version"
   ]
  },
  {
   "PR": {
    "__lazy_json__": "pr_json/232550077.json"
   },
   "data": {
    "bot_rerun": false,
    "migrator_name": "CompilerRebuild",
    "migrator_version": 1,
    "name": "Python 3.7, GCC 7, R 3.5.1, openBLAS 0.3.2"
   },
   "keys": [
    "bot_rerun",
    "migrator_name",
    "migrator_version",
    "name"
   ]
  }
 ],
 "archived": false,
 "bad": "make_graph: render error No module named 'toml'\nTraceback (most recent call last):\n  File \"/home/runner/work/autotick-bot/autotick-bot/cf-scripts/conda_forge_tick/feedstock_parser.py\", line 241, in populate_feedstock_attributes\n    parse_meta_yaml(\n  File \"/home/runner/work/autotick-bot/autotick-bot/cf-scripts/conda_forge_tick/utils.py\", line 167, in parse_meta_yaml\n    return _parse_meta_yaml_impl(\n  File \"/home/runner/work/autotick-bot/autotick-bot/cf-scripts/conda_forge_tick/utils.py\", line 239, in _parse_meta_yaml_impl\n    m = MetaData(tmpdir, config=config, variant=var)\n  File \"/usr/share/miniconda3/envs/run_env/lib/python3.9/site-packages/conda_build/metadata.py\", line 932, in __init__\n    self.parse_again(permit_undefined_jinja=True, allow_no_other_outputs=True)\n  File \"/usr/share/miniconda3/envs/run_env/lib/python3.9/site-packages/conda_build/metadata.py\", line 1007, in parse_again\n    self.meta = parse(self._get_contents(permit_undefined_jinja,\n  File \"/usr/share/miniconda3/envs/run_env/lib/python3.9/site-packages/conda_build/metadata.py\", line 1546, in _get_contents\n    from conda_build.jinja_context import context_processor, UndefinedNeverFail, FilteredLoader\n  File \"/usr/share/miniconda3/envs/run_env/lib/python3.9/site-packages/conda_build/jinja_context.py\", line 13, in <module>\n    import toml\nModuleNotFoundError: No module named 'toml'\n",
 "branch": "main",
 "conda-forge.yml": {
  "compiler_stack": "comp7",
  "max_py_ver": "37",
  "max_r_ver": "35"
 },
 "feedstock_name": "tokyocabinet",
 "hash_type": "sha256",
 "name": "tokyocabinet",
 "new_version": false,
 "outputs_names": {
  "__set__": true,
  "elements": [
   "tokyocabinet"
  ]
 },
 "pinning_version": "2018.11.17",
 "raw_meta_yaml": "{% set name = \"tokyocabinet\" %}\n{% set version = \"1.4.48\" %}\n{% set sha256 = \"a003f47c39a91e22d76bc4fe68b9b3de0f38851b160bbb1ca07a4f6441de1f90\" %}\n\npackage:\n  name: {{ name|lower }}\n  version: {{ version }}\n\nsource:\n  fn: {{ name }}-{{ version }}.tar.gz\n  url: http://fallabs.com/tokyocabinet/{{ name }}-{{ version }}.tar.gz\n  sha256: {{ sha256 }}\n\nbuild:\n  number: 1003\n  skip: True  # [win]\n\n  detect_binary_files_with_prefix: true\n\nrequirements:\n  build:\n    - {{ compiler('c') }}\n    - {{ compiler('cxx') }}\n  host:\n    - zlib\n    - bzip2\n  run:\n    - zlib\n    - bzip2\n\ntest:\n  commands:\n    - test -e $PREFIX/include/tcadb.h  # [unix]\n    - test -e $PREFIX/lib/libtokyocabinet.so  # [linux]\n    - test -e $PREFIX/lib/libtokyocabinet.dylib  # [osx]\n    - test -e $PREFIX/lib/libtokyocabinet.a  # [unix]\n    - test -e $PREFIX/lib/pkgconfig/tokyocabinet.pc  # [unix]\n    - tcbmgr version  # [unix]\n    - echo foo | tcucodec zlib  # [unix]\n\nabout:\n  home: http://fallabs.com/tokyocabinet\n  license: LGPL-2.1\n  license_file: COPYING\n  license_family: LGPL\n  summary: 'Tokyo Cabinet is a high performance key-value store written in C.'\n\n  description: |\n     Tokyo Cabinet is a library of routines for managing a database.\n     The database is a simple data file containing records, each is a pair\n     of a key and a value. Every key and value is serial bytes with\n     variable length. Both binary data and character string can be used as\n     a key and a value. There is neither concept of data tables nor data\n     types. Records are organized in hash table, B+ tree, or fixed-length\n     array.\n\n     Tokyo Cabinet is developed as the successor of GDBM and QDBM on the\n     following purposes. They are achieved and Tokyo Cabinet replaces\n     conventional DBM products.\n\n       improves space efficiency : smaller size of database file.\n       improves time efficiency : faster processing speed.\n       improves parallelism : higher performance in multi-thread environment.\n       improves usability : simplified API.\n       improves robustness : database file is not corrupted even under catastrophic situation.\n       supports 64-bit architecture : enormous memory space and database file are available.\n\n     Tokyo Cabinet is written in the C language, and provided as API of\n     C, Perl, Ruby, Java, and Lua. Tokyo Cabinet is available on platforms\n     which have API conforming to C99 and POSIX. Tokyo Cabinet is a\n     free software licensed under the GNU Lesser General Public License.\n\nextra:\n  recipe-maintainers:\n    - aseyboldt\n",
 "smithy_version": "3.1.12",
 "strong_exports": false,
 "url": "http://fallabs.com/tokyocabinet/tokyocabinet-1.4.48.tar.gz",
 "version": "1.4.48"
}