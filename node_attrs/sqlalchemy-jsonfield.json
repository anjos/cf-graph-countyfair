{
 "PRed": [
  {
   "PR": {
    "__lazy_json__": "pr_json/1a3b46bd-1d0b-421b-9161-25be66e9fd2d.json"
   },
   "data": {
    "bot_rerun": false,
    "migrator_name": "MigrationYaml",
    "migrator_object_version": 1,
    "migrator_version": 0,
    "name": "python38"
   },
   "keys": [
    "bot_rerun",
    "migrator_name",
    "migrator_object_version",
    "migrator_version",
    "name"
   ]
  },
  {
   "PR": {
    "__lazy_json__": "pr_json/390150216.json"
   },
   "data": {
    "bot_rerun": false,
    "migrator_name": "MigrationYaml",
    "migrator_object_version": 1,
    "migrator_version": 0,
    "name": "pypy"
   },
   "keys": [
    "bot_rerun",
    "migrator_name",
    "migrator_object_version",
    "migrator_version",
    "name"
   ]
  },
  {
   "PR": {
    "__lazy_json__": "pr_json/537141983.json"
   },
   "data": {
    "bot_rerun": false,
    "migrator_name": "Version",
    "migrator_version": 0,
    "version": "1.0.0"
   },
   "keys": [
    "bot_rerun",
    "migrator_name",
    "migrator_version",
    "version"
   ]
  }
 ],
 "archived": false,
 "bad": "make_graph: render error No module named 'toml'\nTraceback (most recent call last):\n  File \"/home/runner/work/autotick-bot/autotick-bot/cf-scripts/conda_forge_tick/feedstock_parser.py\", line 241, in populate_feedstock_attributes\n    parse_meta_yaml(\n  File \"/home/runner/work/autotick-bot/autotick-bot/cf-scripts/conda_forge_tick/utils.py\", line 167, in parse_meta_yaml\n    return _parse_meta_yaml_impl(\n  File \"/home/runner/work/autotick-bot/autotick-bot/cf-scripts/conda_forge_tick/utils.py\", line 239, in _parse_meta_yaml_impl\n    m = MetaData(tmpdir, config=config, variant=var)\n  File \"/usr/share/miniconda3/envs/run_env/lib/python3.9/site-packages/conda_build/metadata.py\", line 932, in __init__\n    self.parse_again(permit_undefined_jinja=True, allow_no_other_outputs=True)\n  File \"/usr/share/miniconda3/envs/run_env/lib/python3.9/site-packages/conda_build/metadata.py\", line 1007, in parse_again\n    self.meta = parse(self._get_contents(permit_undefined_jinja,\n  File \"/usr/share/miniconda3/envs/run_env/lib/python3.9/site-packages/conda_build/metadata.py\", line 1546, in _get_contents\n    from conda_build.jinja_context import context_processor, UndefinedNeverFail, FilteredLoader\n  File \"/usr/share/miniconda3/envs/run_env/lib/python3.9/site-packages/conda_build/jinja_context.py\", line 13, in <module>\n    import toml\nModuleNotFoundError: No module named 'toml'\n",
 "branch": "main",
 "conda-forge.yml": {},
 "feedstock_name": "sqlalchemy-jsonfield",
 "hash_type": "sha256",
 "name": "sqlalchemy-jsonfield",
 "new_version": "1.0.0",
 "new_version_attempts": {
  "1.0.0": 1
 },
 "new_version_errors": {},
 "outputs_names": {
  "__set__": true,
  "elements": [
   "sqlalchemy-jsonfield"
  ]
 },
 "pinning_version": "2020.12.11.09.47.37",
 "raw_meta_yaml": "{% set name = \"SQLAlchemy-JSONField\" %}\n{% set version = \"1.0.0\" %}\npackage:\n  name: {{ name|lower }}\n  version: {{ version }}\n\nsource:\n  url: https://pypi.io/packages/source/{{ name[0] }}/{{ name }}/{{ name }}-{{ version }}.tar.gz\n  sha256: 766d0b25bdebf53f67ccfaf9975987f921965987b37bae3a95ba6e7855afe98b\n  patches:\n    - 0001-remove-typing.patch\n\nbuild:\n  number: 2\n  script: {{ PYTHON }} -m pip install . -vv\n  noarch: python\n\n\nrequirements:\n  host:\n    - python >=3.5\n    - pip\n    - setuptools\n    - setuptools_scm\n  run:\n    - python >=3.5\n    - sqlalchemy\n\ntest:\n  imports:\n    - sqlalchemy_jsonfield\n  commands:\n    - pip check\n  requires:\n    - pip\n\nabout:\n  home: https://github.com/penguinolog/sqlalchemy_jsonfield\n  license: Apache-2.0\n  license_family: Apache\n  license_file: LICENSE\n  summary: |\n    SQLALchemy JSONField implementation for storing dicts at SQL independently\n    from JSON type support.\n\n  description: |\n    SqlAlchemy provides JSON field support for several database types\n    (PostgreSQL and MySQL for now) and semi-working dict <-> JSON <-> VARCHAR\n    example, but... In real scenarios we have tests on sqlite, production on\n    MySQL/MariaDB/Percona/PostgreSQL and some of them (modern Oracle MySQL &\n    PostgreSQL) support JSON, some of them (SQLite, Percona & MariaDB) requires\n    data conversion to Text (not VARCHAR).\n\n    As addition, we have different levels of Unicode support on database and\n    connector side, so we may be interested to switch JSON encoding between d\n    eployments.\n  doc_url: https://github.com/penguinolog/sqlalchemy_jsonfield\n  dev_url: https://github.com/penguinolog/sqlalchemy_jsonfield\n\nextra:\n  recipe-maintainers:\n    - xylar\n",
 "smithy_version": "3.8.5",
 "strong_exports": false,
 "url": "https://pypi.io/packages/source/S/SQLAlchemy-JSONField/SQLAlchemy-JSONField-1.0.0.tar.gz",
 "version": "1.0.0"
}