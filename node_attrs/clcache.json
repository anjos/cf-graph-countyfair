{
 "PRed": [
  {
   "data": {
    "bot_rerun": false,
    "migrator_name": "Version",
    "migrator_version": 0,
    "version": "4.1.0"
   },
   "keys": [
    "bot_rerun",
    "migrator_name",
    "migrator_version",
    "version"
   ]
  },
  {
   "PR": {
    "__lazy_json__": "pr_json/213565668.json"
   },
   "data": {
    "bot_rerun": false,
    "migrator_name": "Version",
    "migrator_version": 0,
    "version": "4.2.0"
   },
   "keys": [
    "bot_rerun",
    "migrator_name",
    "migrator_version",
    "version"
   ]
  },
  {
   "PR": {
    "__lazy_json__": "pr_json/217483229.json"
   },
   "data": {
    "bot_rerun": false,
    "migrator_name": "CompilerRebuild",
    "migrator_version": 1,
    "name": "Python 3.7, GCC 7, R 3.5.1, openBLAS 0.3.2"
   },
   "keys": [
    "bot_rerun",
    "migrator_name",
    "migrator_version",
    "name"
   ]
  },
  {
   "PR": {
    "__lazy_json__": "pr_json/335627540.json"
   },
   "data": {
    "bot_rerun": false,
    "migrator_name": "MigrationYaml",
    "migrator_object_version": 1,
    "migrator_version": 0,
    "name": "python38"
   },
   "keys": [
    "bot_rerun",
    "migrator_name",
    "migrator_object_version",
    "migrator_version",
    "name"
   ]
  },
  {
   "PR": {
    "__lazy_json__": "pr_json/391784392.json"
   },
   "data": {
    "bot_rerun": false,
    "migrator_name": "MigrationYaml",
    "migrator_object_version": 1,
    "migrator_version": 0,
    "name": "pypy"
   },
   "keys": [
    "bot_rerun",
    "migrator_name",
    "migrator_object_version",
    "migrator_version",
    "name"
   ]
  },
  {
   "PR": {
    "__lazy_json__": "pr_json/502196190.json"
   },
   "data": {
    "bot_rerun": false,
    "migrator_name": "MigrationYaml",
    "migrator_object_version": 2,
    "migrator_version": 0,
    "name": "python39"
   },
   "keys": [
    "bot_rerun",
    "migrator_name",
    "migrator_object_version",
    "migrator_version",
    "name"
   ]
  },
  {
   "PR": {
    "__lazy_json__": "pr_json/bc4a3f7b-23ad-4780-9f17-ed4288eff92a.json"
   },
   "data": {
    "bot_rerun": false,
    "migrator_name": "MigrationYaml",
    "migrator_object_version": 1,
    "migrator_version": 0,
    "name": "pypy37"
   },
   "keys": [
    "bot_rerun",
    "migrator_name",
    "migrator_object_version",
    "migrator_version",
    "name"
   ]
  }
 ],
 "archived": false,
 "bad": "make_graph: render error No module named 'toml'\nTraceback (most recent call last):\n  File \"/home/runner/work/autotick-bot/autotick-bot/cf-scripts/conda_forge_tick/feedstock_parser.py\", line 241, in populate_feedstock_attributes\n    parse_meta_yaml(\n  File \"/home/runner/work/autotick-bot/autotick-bot/cf-scripts/conda_forge_tick/utils.py\", line 167, in parse_meta_yaml\n    return _parse_meta_yaml_impl(\n  File \"/home/runner/work/autotick-bot/autotick-bot/cf-scripts/conda_forge_tick/utils.py\", line 239, in _parse_meta_yaml_impl\n    m = MetaData(tmpdir, config=config, variant=var)\n  File \"/usr/share/miniconda3/envs/run_env/lib/python3.9/site-packages/conda_build/metadata.py\", line 932, in __init__\n    self.parse_again(permit_undefined_jinja=True, allow_no_other_outputs=True)\n  File \"/usr/share/miniconda3/envs/run_env/lib/python3.9/site-packages/conda_build/metadata.py\", line 1007, in parse_again\n    self.meta = parse(self._get_contents(permit_undefined_jinja,\n  File \"/usr/share/miniconda3/envs/run_env/lib/python3.9/site-packages/conda_build/metadata.py\", line 1546, in _get_contents\n    from conda_build.jinja_context import context_processor, UndefinedNeverFail, FilteredLoader\n  File \"/usr/share/miniconda3/envs/run_env/lib/python3.9/site-packages/conda_build/jinja_context.py\", line 13, in <module>\n    import toml\nModuleNotFoundError: No module named 'toml'\n",
 "branch": "main",
 "conda-forge.yml": {},
 "feedstock_name": "clcache",
 "hash_type": "sha256",
 "name": "clcache",
 "new_version": "4.2.0",
 "outputs_names": {
  "__set__": true,
  "elements": [
   "clcache"
  ]
 },
 "pinning_version": "2021.01.10.01.07.36",
 "raw_meta_yaml": "{% set name = \"clcache\" %}\n{% set version = \"4.2.0\" %}\n\npackage:\n  name: {{ name|lower }}\n  version: {{ version }}\n\nsource:\n  url: https://pypi.io/packages/source/{{ name[0] }}/{{ name }}/clcache-{{ version }}.tar.gz\n  sha256: 41bcc460098463dfaf3b2b6c5f1db91548bb1d5f4243bed3bcbb9740a579246c\n\nbuild:\n  number: 0\n  skip: true  # [not win]\n  entry_points:\n    - clcache = clcache.__main__:main\n    - clcache-server = clcache.server.__main__:main\n  script: {{ PYTHON }} -m pip install . -vv\n\nrequirements:\n  host:\n    - python\n    - pip\n    - setuptools_scm\n  run:\n    - python\n    - pymemcache\n    - pyuv\n\ntest:\n  imports:\n    - clcache\n    - clcache.server\n  commands:\n    - pip check\n    - clcache --help\n    - clcache-server --help\n  requires:\n    - pip\n\nabout:\n  home: https://github.com/frerich/clcache\n  license: BSD-3-Clause\n  license_file: LICENSE\n  summary: 'a compiler cache for Microsoft Visual Studio'\n\n  description: |\n    clcache.py is a little Python script which attempts to avoid unnecessary\n    recompilation by reusing previously cached object files if possible.\n    It is meant to be called instead of the original 'cl.exe' executable.\n    The script analyses the command line to decide whether source code is to be compiled.\n    If so, a cache will be queried for a previously stored object file.\n\n    If the script is called in an unsupported way (e.g. if the compiler is called for linking),\n    the script will simply relay the invocation to the real 'cl.exe' program.\n\nextra:\n  recipe-maintainers:\n    - edisongustavo\n    - tadeu\n    - nicoddemus\n    - xhochy\n",
 "smithy_version": "3.8.6",
 "strong_exports": false,
 "url": "https://pypi.io/packages/source/c/clcache/clcache-4.2.0.tar.gz",
 "version": "4.2.0"
}